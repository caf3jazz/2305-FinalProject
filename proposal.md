# Procedural Text Art Generator

## Repository
<https://github.com/caf3jazz/2305-FinalProject.git>

## Description
The Procedural Text Art Generator will create dynamic, randomized text-based patterns in a grid format. This project is relevant to digital arts as it explores procedural art generation, producing visual interest through simple code and randomization techniques.



## Features
- Randomized Pattern Generation
	- Displays a grid of random symbols or letters to form unique patterns. This will be achieved using loops and Python’s random library.
- User-Controlled Symbols and Colors 2
	- Users can choose which symbols to display or adjust color settings (if supported by the library). This will use basic user input and conditional logic to customize output..
- Animation Effect
	- Continuously refreshes the grid to create a “moving” effect, giving the appearance of dynamic patterns. This will be implemented with Python’s time library to control update intervals.

## Challenges
- Learning how to use Python’s random and time libraries to handle randomization and timing.
- Implementing text-based graphics in Python to display symbols creatively in a grid.
- Managing loops and conditionals to control the flow and responsiveness of the animation effect.

## Outcomes
Ideal Outcome:
- An animated display where users can customize symbols and colors, with patterns shifting dynamically over time.

Minimal Viable Outcome:
- A static grid pattern that displays randomized symbols based on user input, refreshed at set intervals without continuous animation.

## Milestones

- Week 1
  1. Set up GitHub repository and basic project structure.
  2. Research Python’s random and time libraries for generating and timing text patterns.
  3. Build a basic grid that displays random symbols.

- Week 2
  1. Test loops and intervals to refresh the grid and ensure smooth updates.
  2. Add customization options for symbols and potentially colors.
  3. Refine the randomization and ensure responsiveness of the grid.

- Week N (Final)
  1. Finalize the program and clean up code.
  2. Record the demonstration video and complete the README documentation.
